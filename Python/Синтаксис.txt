Вывод:
print()
print(smth, smth, smth, sep='чем разделять элементы строки', end='чем закончить строку ')

Типы данных:
[] - list (массив)
set - множество
frozenset - неизменяемый после создания список

Ввод:
input()
name=input()
type(input())
EG int(input())
(len(ПЕРЕМЕННАЯ)) - выводит длинну строковой переменной
s[n] - вывести n-ый символ строки s
s[n:v] - c n по v
s[n:v:k] - k шаг
s[::k]
переменная = [] - объявить пустой список "переменная"
Генератор списка: a=[что мы делаем с переменной или какой тип данных for значения для переменной in область значений]
Генератор двумерного массива: [[0] * m for i in range(n)]

def functionname(n): (если *n - то все параметры станут n, то есть списком)
function
return n
Global a - объявляет переменную а глобальной внутри функции











ФУНКЦИИ:

Преобразование к типу:
int(n) - возвращает n в виде integer










try:
smth
expcept KeyError:
somtehing else


Циклы:
if nnnn:
 esmfsf
else:
 feoinsif
i += i: i=i+1

for ПЕРЕМЕННАЯ in перечисление возможных значений:
 делай что-нибудь (будет делать пока не кончатся переменные)
for ПЕРЕМЕННАЯ in range(диапазон ДО числа, либо *a, b* где a - начало, а b-1 - конец; если три переменных - третья это то, на сколько изменится индекс)
 делай что-нибудь (сделает столько раз, сколько доступно диапазону)

(если ничего не нужно делать в протином случае - убрать else)
(если дополнительное условие - elif и только потом else)


while условие
  делать пока условие истинно
else
  делать если условие ложно

break - прерывает любой цикл, запрещая даже else

continue - цикл повторяется заново






Списки
x in A - есть ли элемент в списке
x not in A - напротив
min(A) - наименьший (также наибольший) элемент списка
A.index(x) - индекс первого вхождения х
A.count(x) - количество вхождений х
for row in a:
    print(' '.join(row)) - вывод массива
ПЕРЕМЕННАЯ.find('что найти')
ПЕРЕМЕННАЯ.rfind('что найти справа (с конца)')
Файнды выдают число, где нашли что надо
ПЕРЕМЕННАЯ.replace('что меняем', 'на что меняем', сколько первых разрешено поменять)
ПЕРЕМЕННАЯ.count('что считаем')
ПЕРЕМЕННАЯ.append(новыйэлементсписка)
a=ПЕРЕМЕННАЯ.split(k) - разделяет список на строки в списке, k - знаки которые разделяются
'чем разделяем'.join(a)
a[1:5:1] - срез с 1 по 5 элемент, с шагом 1
Это работает для списков и строк
Но в списках можно менять элементы посреди среза (a[n:k]=[1,2,3])


Множества:
a=list(c)
a.discard(x)
a.remove(x)
a.pop(x)
a=set('') - создание\изменение множества 
x in a
a.add(x)
a|b 	с=a.union(b) - объединить два множества
a |=b 	a.update(b) - присоединить b к а
a&b	c=a.intersection(b) - множество, явл пересечением двух других
a&=b	a.intersection_update(b) - оставляет в а только то, что общего в b
a-b	c=a.difference(b) - то, что есть в а но нет в b
a-=b	a.difference_update(b) - возвращает в а то, что есть в а но нет в б
a^b	с=a.symmetric_difference(b) - все, кроме общих элементов
a^=b 	a.symmetric_difference_update(b) - записывает то же самое в а
a<=b 	a.issubset(b) - true если а - подмножество b
a>=b a.issuperset(b) - true если б - подмножество а
a<b
a>b

set.union(*x) и тд - т.к. х у нас список, а все его члены - множество, то он проводит операцию со всеми множествами внутри, возвращая единственное множество

Сортировка:
sorted(a, key=int)
*sorted - волшебным образом убирает квадратные скобки (мы указываем ему, что работаем со списком?)





Функции
min - возвращает минимум из двух чисел
max - возвращает максимальное из двух
len - демонстрирует длину строки или массива

def  smth(a) - задать функцию от а
def smth(*a) - a превращается в array
return l - возвращает в а значение l


Словари:
Ввод:
Capitals = {'Russia': 'Moscow', 'Ukraine': 'Kiev', 'USA': 'Washington'}

Capitals = dict(Russia = 'Moscow', Ukraine = 'Kiev', USA = 'Washington')

Capitals = dict([("Russia", "Moscow"), ("Ukraine", "Kiev"), ("USA", "Washington")])
Capitals = dict(zip(["Russia", "Ukraine", "USA"], ["Moscow", "Kiev", "Washington"]))
print(Capitals)

d = {a: a ** 2 for a in range(7)}
>>> d
{0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36}

a[key] = то, что по ключу (если нет - ошибка)
a.get(key) = то, что по ключу (если нет - возвращает none)
a.get(key, val) - если элемента под этим ключом нет, то возвращает val
del a[key]
a.pop(key) - удаляет key и возвращает его. Если добавить val - возвратит его в случае неудачи
a.items() - перечисление всех элементов словаря в виде списка
a.keys() - возвращает все ключи словаря
a.values() - перечисление всех значений (не ключей) словаря








Хитрости:
\n - новая линия, в разделителе - эквивалент энтера
*sorted - пока сортирует множество, превращает его в список
zip(list1\str, list2\str2) - разделяет значения и присваивает их друг другу:
zip('abcdef', '123456') - (a, 1), (b, 2), (c, 3) и т.д.
for _ in range(n) если не понадобится значение, можно не использовать значение


try:
	try something
except SomethingError:
	print("this is error")




Математика и операторы:
Вычисления идут как формулы вне комманд
Операторы сравнения:
<
>
<=
>=
==
!=
Логические:
and
or
not
математические операторы:
+
-
*
** - степень
/ - float
// - int
% - с остатком (дает остаток), деление по модулю

abs - absolute, модуль


Типы данных:
int - integer
str - string
bool - boolean
float - плавающая
1.0001e10 - научная запись (10 - порядок, остальное - мантисса)


Модули:
from x import y (from math import ceil)
Math (import math)
	




math.ceil(X) – округление до ближайшего большего числа.

math.copysign(X, Y) - возвращает число, имеющее модуль такой же, как и у числа X, а знак - как у числа Y.

math.fabs(X) - модуль X.

math.factorial(X) - факториал числа X.

math.floor(X) - округление вниз.

math.fmod(X, Y) - остаток от деления X на Y.

math.frexp(X) - возвращает мантиссу и экспоненту числа.

math.ldexp(X, I) - X * 2i. Функция, обратная функции math.frexp().

math.fsum(последовательность) - сумма всех членов последовательности. Эквивалент встроенной функции sum(), но math.fsum() более точна для чисел с плавающей точкой.

math.isfinite(X) - является ли X числом.

math.isinf(X) - является ли X бесконечностью.

math.isnan(X) - является ли X NaN (Not a Number - не число).

math.modf(X) - возвращает дробную и целую часть числа X. Оба числа имеют тот же знак, что и X.

math.trunc(X) - усекает значение X до целого.

math.exp(X) - eX.

math.expm1(X) - eX - 1. При X > 0 точнее, чем math.exp(X)-1.

math.log(X, [base]) - логарифм X по основанию base. Если base не указан, вычисляется натуральный логарифм.

math.log1p(X) - натуральный логарифм (1 + X). При X > 0 точнее, чем math.log(1+X).

math.log10(X) - логарифм X по основанию 10.

math.log2(X) - логарифм X по основанию 2. Новое в Python 3.3.

math.pow(X, Y) - XY.

math.sqrt(X) - квадратный корень из X.

math.acos(X) - арккосинус X. В радианах.

math.asin(X) - арксинус X. В радианах.

math.atan(X) - арктангенс X. В радианах.

math.atan2(Y, X) - арктангенс Y/X. В радианах. С учетом четверти, в которой находится точка (X, Y).

math.cos(X) - косинус X (X указывается в радианах).

math.sin(X) - синус X (X указывается в радианах).

math.tan(X) - тангенс X (X указывается в радианах).

math.hypot(X, Y) - вычисляет гипотенузу треугольника с катетами X и Y (math.sqrt(x * x + y * y)).

math.degrees(X) - конвертирует радианы в градусы.

math.radians(X) - конвертирует градусы в радианы.

math.cosh(X) - вычисляет гиперболический косинус.

math.sinh(X) - вычисляет гиперболический синус.

math.tanh(X) - вычисляет гиперболический тангенс.

math.acosh(X) - вычисляет обратный гиперболический косинус.

math.asinh(X) - вычисляет обратный гиперболический синус.

math.atanh(X) - вычисляет обратный гиперболический тангенс.

math.erf(X) - функция ошибок.

math.erfc(X) - дополнительная функция ошибок (1 - math.erf(X)).

math.gamma(X) - гамма-функция X.

math.lgamma(X) - натуральный логарифм гамма-функции X.

math.pi - pi = 3,1415926...

math.e - e = 2,718281...




Операции с множествами

A | B 
A.union(B)
Возвращает множество, являющееся объединением множеств A и B.

A |= B 
A.update(B)
Добавляет в множество A все элементы из множества B.

A & B 
A.intersection(B)
Возвращает множество, являющееся пересечением множеств A и B.

A &= B 
A.intersection_update(B)
Оставляет в множестве A только те элементы, которые есть в множестве B.

A - B 
A.difference(B)
Возвращает разность множеств A и B (элементы, входящие в A, но не входящие в B).

A -= B 
A.difference_update(B)
Удаляет из множества A все элементы, входящие в B.

A ^ B 
A.symmetric_difference(B)
Возвращает симметрическую разность множеств A и B (элементы, входящие в A или в B, но не в оба из них одновременно).

A ^= B 
A.symmetric_difference_update(B)
Записывает в A симметрическую разность множеств A и B.

A <= B 
A.issubset(B)
Возвращает true, если A является подмножеством B.

A >= B 
A.issuperset(B)
Возвращает true, если B является подмножеством A.

A < B
Эквивалентно A <= B and A != B

A > B
Эквивалентно A >= B and A != B




MATH:
round(x, n) - round x to n signs (0 by default)
floor(x)
ceil(x)
abs(x) - default function, no math. needed
sqrt(x) - square root
log(x) - log by 10
e - constant
sin(x)
cos(x)
tan(x)
asin(x)
acos(x)
atan(x)
atan2(y, x) - поляный угол (?)
degrees(x) - radians to degs
radians - degs to radians
pi - pi